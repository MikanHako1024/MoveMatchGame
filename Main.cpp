
/* 移动火柴游戏 */ 
/* 移动火柴使等式出成立 */

// 改胡乱地凑出答案
// 为仔细地分析


// 改全遍历 
// 遍历可能形成的数字 


// 移动火柴想到与添加、减少火柴 


// 先按所用火柴个数分类 
//              0  1  2  3  4  5  6  7  8  9
//int _CNT[10]={6, 2, 5, 5, 4, 5, 6, 4, 7, 6};


// 列举增加及减少一根火柴之后可形成的数字 
// 0+: 8
// 1+: 
// 2+: 
// 3+: 
// 4+: 
// 5+: 6 9
// 6+: 8
// 7+: 
// 8+: 
// 9+: 8

// 减少一根 是 逆操作的添加一根 
// 0-: 
// 1-: 
// 2-: 
// 3-: 
// 4-: 
// 5-: 
// 6-: 5
// 7-: 
// 8-: 0 6 9
// 9-: 5

// 减增一根 的 逆操作 即是 其自身 
// 0-+: 6 9
// 1-+: 
// 2-+: 3
// 3-+: 2 5
// 4-+: 7
// 5-+: 3
// 6-+: 0 9
// 7-+: 4
// 8-+: 
// 9-+: 0 6




// 游戏套路：
// 1.不改变符号只改变数字 
// 2.改变符号和数字 
// 3.不改变数字只改变符号 
// 4.倒过来看 
// ps: 等号可 -成负号 -+成加号



#include <stdio.h>


int _PRIZM[10]={  // 二进制存 15位0/1 
/*0*/	31599, 	
/*1*/	4681, 
/*2*/	29671, 
/*3*/	29647, 
/*4*/	23497, 
/*5*/	31183, 
/*6*/	31215, 
/*7*/	31561, 
/*8*/	31727, 
/*9*/	31695, 
};

/*
111101101101111
31599
001001001001001
4681
111001111100111
29671
111001111001111
29647
101101111001001
23497
111100111001111
31183
111100111101111
31215
111101101001001
31561
111101111101111
31727
111101111001111
31695
*/

// 打印 
void Print(int num)
{
	if( num<0 || num>9 )return ;
	
	int k, n=_PRIZM[num], cnt=0;
	for(k=1<<(15-1); k>0; k>>=1)
		printf("%s%c", (k&n)?("■"):("  "), ((++cnt)%3==0)?('\n'):(' '));
	printf("\n"); 
}

// 录字模 
int __ScanZM()
{
	int i, j, n=0; 
	char t;
	for(i=0; i<5; i++)
		for(j=0; j<3; j++)
		{
			do
			{
				scanf("%c", &t);
			}while( !(t=='1' || t=='0') );
			
			n=(n<<1)^(t-'0'); // (n<<1)+(t-'0');
		}
	printf("%d\n", n);
	return n;
}

void _ScanZM()
{
	int z, arr[10];
	for(z=0; z<=9; z++)
		arr[z]=__ScanZM();
	
	for(z=0; z<=9; z++)
		printf("%d ", arr[z]);
	printf("\n");
}

// 待 完成输出使用 Print 


int DE[10][4]={
/*0*/	{ 0 }, 
/*1*/	{ 0 }, 
/*2*/	{ 0 }, 
/*3*/	{ 0 }, 
/*4*/	{ 0 }, 
/*5*/	{ 0 }, 
/*6*/	{ 1, 5 }, 
/*7*/	{ 0 }, 
/*8*/	{ 3, 0, 6, 9 }, 
/*9*/	{ 1, 5 }, 
};

//int IN[10][2]={
int IN[10][4]={
/*0*/	{ 1, 8 }, 
/*1*/	{ 0 }, 
/*2*/	{ 0 }, 
/*3*/	{ 0 }, 
/*4*/	{ 0 }, 
/*5*/	{ 1, 9 }, 
/*6*/	{ 1, 8 }, 
/*7*/	{ 0 }, 
/*8*/	{ 0 }, 
/*9*/	{ 1, 8 }, 
};

//int DEIN[10][3]={
int DEIN[10][4]={
/*0*/	{ 2, 6, 9 }, 
/*1*/	{ 0 }, 
/*2*/	{ 1, 3 }, 
/*3*/	{ 2, 2, 5 }, 
/*4*/	{ 1, 7}, 
/*5*/	{ 1, 3 }, 
/*6*/	{ 2, 0, 9 }, 
/*7*/	{ 1, 4 }, 
/*8*/	{ 0 }, 
/*9*/	{ 2, 0, 6 }, 
};

int MS[10][4]={ 
/*0*/	{ 1, 0 }, 
/*1*/	{ 1, 1 }, 
/*2*/	{ 1, 2 }, 
/*3*/	{ 1, 3 }, 
/*4*/	{ 1, 4 }, 
/*5*/	{ 1, 5 }, 
/*6*/	{ 1, 6 }, 
/*7*/	{ 1, 7 }, 
/*8*/	{ 1, 8 }, 
/*9*/	{ 1, 9 }, 
};




int OPE[4][10][4]={

{ // DE[10][4]
/*0*/	{ 0 }, 
/*1*/	{ 0 }, 
/*2*/	{ 0 }, 
/*3*/	{ 0 }, 
/*4*/	{ 0 }, 
/*5*/	{ 0 }, 
/*6*/	{ 1, 5 }, 
/*7*/	{ 0 }, 
/*8*/	{ 3, 0, 6, 9 }, 
/*9*/	{ 1, 5 }, 
}, 

{ // IN[10][4]
/*0*/	{ 1, 8 }, 
/*1*/	{ 0 }, 
/*2*/	{ 0 }, 
/*3*/	{ 0 }, 
/*4*/	{ 0 }, 
/*5*/	{ 1, 9 }, 
/*6*/	{ 1, 8 }, 
/*7*/	{ 0 }, 
/*8*/	{ 0 }, 
/*9*/	{ 1, 8 }, 
}, 

{ // MS[10][4]
/*0*/	{ 1, 0 }, 
/*1*/	{ 1, 1 }, 
/*2*/	{ 1, 2 }, 
/*3*/	{ 1, 3 }, 
/*4*/	{ 1, 4 }, 
/*5*/	{ 1, 5 }, 
/*6*/	{ 1, 6 }, 
/*7*/	{ 1, 7 }, 
/*8*/	{ 1, 8 }, 
/*9*/	{ 1, 9 }, 
}, 

{ // DEIN[10][4]
/*0*/	{ 2, 6, 9 }, 
/*1*/	{ 0 }, 
/*2*/	{ 1, 3 }, 
/*3*/	{ 2, 2, 5 }, 
/*4*/	{ 1, 7}, 
/*5*/	{ 1, 3 }, 
/*6*/	{ 2, 0, 9 }, 
/*7*/	{ 1, 4 }, 
/*8*/	{ 0 }, 
/*9*/	{ 2, 0, 6 }, 
} 

};



// 十以内的两个数的加减 _ 对数字减增 
void _f0(int a, int b, int c) // 原'+' (待改用 mod) 
{
	int n[3]={a, b, c}; // a b c 
	//int tn[3];
	//int zd, zi, zm;
	
	int ope[3]; // opea opeb opec
	int z[3]; // za zb zc
	
	for(ope[0]=0; ope[0]<3; ope[0]++)
	{
		for(ope[1]=0; ope[1]<3; ope[1]++)
		{
			if( ope[1]==ope[0] )continue;
			for(ope[2]=0; ope[2]<3; ope[2]++)
			{
				if( ope[2]==ope[0] )continue;
				if( ope[2]==ope[1] )continue;
				
				for(z[0]=1; z[0]<=OPE[ope[0]][n[0]][0]; z[0]++)
				for(z[1]=1; z[1]<=OPE[ope[1]][n[1]][0]; z[1]++)
				for(z[2]=1; z[2]<=OPE[ope[2]][n[2]][0]; z[2]++)
					if( OPE[ope[0]][n[0]][z[0]]+
						OPE[ope[1]][n[1]][z[1]]==
						OPE[ope[2]][n[2]][z[2]] )
						{
							printf("%d + ", OPE[ope[0]][n[0]][z[0]]);
							printf("%d = ", OPE[ope[1]][n[1]][z[1]]);
							printf("%d \n", OPE[ope[2]][n[2]][z[2]]);
						}
			}
		}
	}
}

// 十以内的两个数的加减 _ 对数字增 '+'减成'-' 
void _f1(int a, int b, int c) // 原'+' (若不改变'=' 只数字增 必定原'+') 
{
	int n[3]={a, b, c}; // a b c
	int ope[3]; // opea opeb opec
	int z[3]; // za zb zc
	
	int t;
	for(t=0; t<3; t++)
	{
		ope[0]=2; ope[1]=2; ope[2]=2;
		ope[t]=1;
		
		for(z[0]=1; z[0]<=OPE[ope[0]][n[0]][0]; z[0]++)
		for(z[1]=1; z[1]<=OPE[ope[1]][n[1]][0]; z[1]++)
		for(z[2]=1; z[2]<=OPE[ope[2]][n[2]][0]; z[2]++)
			if( OPE[ope[0]][n[0]][z[0]]-
				OPE[ope[1]][n[1]][z[1]]==
				OPE[ope[2]][n[2]][z[2]] )
				{
					printf("%d - ", OPE[ope[0]][n[0]][z[0]]);
					printf("%d = ", OPE[ope[1]][n[1]][z[1]]);
					printf("%d \n", OPE[ope[2]][n[2]][z[2]]);
				}
	}
}

// 十以内的两个数的加减 _ 对数字减 '-'加成'+' 
void _f2(int a, int b, int c) // 原'-' (若不改变'=' 只数字减 必定原'-') 
{
	int n[3]={a, b, c}; // a b c
	int ope[3]; // opea opeb opec
	int z[3]; // za zb zc
	
	int t;
	for(t=0; t<3; t++)
	{
		ope[0]=2; ope[1]=2; ope[2]=2;
		ope[t]=0;
		
		for(z[0]=1; z[0]<=OPE[ope[0]][n[0]][0]; z[0]++)
		for(z[1]=1; z[1]<=OPE[ope[1]][n[1]][0]; z[1]++)
		for(z[2]=1; z[2]<=OPE[ope[2]][n[2]][0]; z[2]++)
			if( OPE[ope[0]][n[0]][z[0]]+
				OPE[ope[1]][n[1]][z[1]]==
				OPE[ope[2]][n[2]][z[2]] )
				{
					printf("%d + ", OPE[ope[0]][n[0]][z[0]]);
					printf("%d = ", OPE[ope[1]][n[1]][z[1]]);
					printf("%d \n", OPE[ope[2]][n[2]][z[2]]);
				}
	}
}

// 待 合并

// 待 优化函数名 变量名 等 

 
// 十以内的两个数的加减
void f(int a, int mod, int b, int c)
{
	printf("Question : %d %c %d = %d\n", a, (mod==1)?('+'):('-'), b, c);
	printf("Answer :   ");
	 
	if( mod==1 ) // '+'
	{
		_f0(a, b, c);
		_f1(a, b, c);
	}
	else if( mod==2 ) // '-'
	{
		_f0(a, b, c);
		_f2(a, b, c);
	}
	else {}
}


int main()
{
	//_ScanZM();
	// test Print
	/*
	int n;
	for(n=0; n<=9; n++)
		Print(n);
	*/
	
	
	f(6, 1, 8, 8); // 6+8=8 -> 8+0=8
	
	f(6, 1, 0, 8); // 6+0=8 -> 8-0=8
	
	f(8, 2, 9, 9); // 8-9=9 -> 0+9=9
	
	f(5, 1, 3, 6); // 5+3=6 -> 9-3=6
	
	
	// 待 添加输入功能
	
	 
	return 0;
}


/*
・・・
・  ・
・・・
・  ・
・・・ 

■■■
■  ■
■■■
■  ■
■■■
*/


// 待 优化 

